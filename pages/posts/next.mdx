---
title: 'Introduction to Next.js'
layout: 'post'
---

## Routing in Next.js

### How to variable in route (Dynamic Route)

So to create a dynamic route, we can create a file that looks like this:

```
[id].jsx
```

Where `id` is the name of the parameter. You can name it whatever you want. Those brackets are not a typo or a placeholder; that's the syntax to create a dynamic route using file name conventions in the pages directory. So let's create our note route:

```
pages
  notes
    index.jsx
    [id].jsx
```

### Link in button with variable route

```jsx
<Link href="/user/[id].js" as={`/user/${user.id}`}>
  <a>user</a>
</Link>
```

### Programmatically Route (Methods like router.push etc)

For when you need to route between pages programmatically, you can use the router to do so. There are [many methods](https://nextjs.org/docs/routing/introduction) on the router that you can use, so we'll focus on the ones we'll use in this course.

Just like the `Link` component, use the router for client-side routing. To navigate to a page, you can use the `push` method, which works like `href` on the `Link` component.

```jsx
import React from 'react'
import { useRouter } from 'next/router'

export default () => {
  const router = useRouter()
  const id = 2

  return (
    <div>
      <button onClick={(e) => router.push('/')}>Go Home</button>

      <button onClick={(e) => router.push('/user/[id]', `/user/${id}`)}>
        Dashboard
      </button>
    </div>
  )
}
```

And that's all there is to routing!

## Adding CSS & Modules

### Global CSS is in \_app

To add Global CSS, you can put it on \_app folder
Create an `pages/_app.jsx` file and add this:

```jsx
export default function App({ Component, pageProps }) {
  return <Component {...pageProps} />
}
```

This automatically gets created for you by default with the same code. In the `_app.jsx` you can import any CSS file, and the styles will be global now.

```jsx
import 'flexbox.css'
import '../mystyles.css'
```

### CSS Modules

Now, when you don't want global CSS, Next.js supports [css modules](https://github.com/css-modules/css-modules). This will scope your CSS, avoiding collisions.

> üï≥ ¬†¬†**deep dive**: a unique class name is created every import to reuse the same CSS class names

You can import a CSS module file anywhere in your app. To create a CSS module, you have to use a special syntax in the file name.

`styles.module.css`

This makes CSS modules a perfect solution to styling components.

```
components
  button.jsx
  button.module.css
```

### Adding Theme UI (Not specific to Next.js.)

https://hendrixer.github.io/nextjs-course/themeui

## Customizing Next.js

next.config.js, webpack { } all webpack config inside there, like plugins and stuff
Just keep in mind that next.js have this feature, no need to worry about this for now.

## Plugins

Next.js has plugins! use for env variables for example.

**yarn**

```shell
yarn add next-env dotenv-load
```

In your `next.config.js` file:

```js
const nextEnv = require('next-env')
const dotenvLoad = require('dotenv-load')

dotenvLoad()

const withNextEnv = nextEnv()
module.exports = withNextEnv()
```

Next, create a `.env` file on the root and add some envs.

```
HELP_APP_URL=https://google.com
```

> ‚ö†Ô∏è ¬†¬†**warning**: don't check .env files into git

Now, we'll use the env in our app. Go to the Nav component and add an `a` tag to link to the external app.

```jsx
// src/components/nav.jsx
<a
  sx={{
    color: 'text',
    fontSize: 3,
    cursor: 'pointer',
  }}
  href={process.env.HELP_APP_URL}
>
  Help
</a>
```

## Typescript in Next.js

Just make tsconfig.json

## API Routes

Next.js is a full stack framework, you can make API!

```
pages
  api
    hello.js
```

> üëçüèæ ¬†¬†**tip**: Next.js API routes are not the same as Vercel's Serverless API functions, although the setup is similar.

## API Handlers

A handler looks like this:

```js
// pages/api/data.js
// route => /api/data

export default (req, res) => {
  res.statusCode = 200
  res.setHeader('Content-Type', 'application/json')
  res.end(JSON.stringify({ message: 'hello' }))
}
```

That's it, you have a full fledged API, can someone show me a framework that makes it easier to do this üòè

But that has no header thing, all PUT GET POST returns that, how to specify it?

> HTTPie is cURL for humans, worth to try.
> `http PUT :3000/api`

### Express-like handler.

We can quickly look at the incoming request and get the method, and we can create some HOF's to handle middleware, but I landed on an excellent package that helps with this.

```js
// pages/api/data
import nc from 'next-connect'
import cors from 'cors'

const handler = nc()
  // use connect based middleware
  .use(cors())
  // express like routing for methods
  .get((req, res) => {
    // can also be async (req,res) for async
    res.send('Hello world')
  })
  .post((req, res) => {
    res.json({ hello: 'world' })
  })
  .put(async (req, res) => {
    res.end('hello')
  })

export default handler
```

You can get an app moving realy quick really fast with this.

Pretty clean! Now, let's create some API routes for our Notes app. We need some basic CRUD:

```
//TODO
create note => POST /api/note
update note => PATCH /api/note/:id
delete note => DELETE /api/note/:id
get one note => GET /api/note/:id
get all notes => GET /api/note/
```

## Create and Get all Notes

### Dummy database

We dont cover database because it will be a distraction here, so create data.js in src/data/data.js

```js
const notes = []

module.exports = notes // must be module.exports, not es6
```

### Create, Get All in index.js

```js
import nc from 'next-connect'
import notes from '../../../src/data/data'

const handler = nc()
  .post((req, res) => {
    const note = {
      ...req.body,
      id: Date.now(),
    }
    notes.push(note)
    res.json({ data: note })
  })
  .get((req, res) => {
    res.json({ data: notes })
  })

export default handler // dont forget to export lol
```

### Update, Get One, Delete in [id].js

req.query.id not params like express, notice how query looks like in router.query in paging.
And we parse int here because in request the id as string, but in data.js its integer

```js
// pages/api/note/[id].js
import nc from 'next-connect'
import notes from '../../../src/data/data'

const getNote = (id) => notes.find((n) => n.id === parseInt(id))

const handler = nc()
  .get((req, res) => {
    const note = getNote(req.query.id)

    if (!note) {
      res.status(404)
      res.end()
      return
    }

    res.json({ data: note })
  })
  .patch((req, res) => {
    const note = getNote(req.query.id)

    if (!note) {
      res.status(404)
      res.end()
      return
    }

    const i = notes.findIndex((n) => n.id === parseInt(req.query.id))
    const updated = { ...note, ...req.body }

    notes[i] = updated
    res.json({ data: updated })
  })
  .delete((req, res) => {
    const note = getNote(req.query.id)

    if (!note) {
      res.status(404)
      res.end()
      return
    }
    const i = notes.findIndex((n) => n.id === parseInt(req.query.id))

    notes.splice(i, 1)

    res.json({ data: req.query.id })
  })

export default handler
```

## Fetching Data

This section is what **defines Next.js and it's power.**
There are many ways to fetch data with Next.js. Depending on when you need the data and what you're doing with it, you have options.

Let's start with what you already know. You can continue to fetch the data client-side to react the same way you do now. Hooks, fetch, etc.

> üëçüèæ¬†¬†**tip**: Next.js injects `fetch` into your environment.

> üëçüèæ¬†¬†**tip**: Checkout [swr](https://swr.vercel.app/) and [react-query](https://react-query.tanstack.com/) for your client side data fetching needs.

Now, for fetching data ahead time, we have three options.

`getStaticProps`

`getStaticPaths`

`getServerSideProps`

### Static Data (getStaticProps)

All of these methods are for prerendering Pages only. You cannot use them in components or client-side data fetching. Let's talk about `getStaticProps` on a page.

```jsx
// /pages/index.js

const IndexPage = () => {// jsx }
export default IndexPage

export async function getStaticProps(context) {
  return {
    props: {}
  }
}
```

By having your page export `getStaticPros`, Next.js will run this function at **build time**. Whatever your return as props will be passed into the exported page.

> üï≥ ¬†¬†**deep dive**: The results of this function are saved into a JSON file and passed as props to the client's component at runtime.

This function and all other data fetching functions will only ever run on the server. The actual code won't even be bundled with the client code. That means you can do some exciting things here:

- file system work
- connect to a DB
- crawl a website? Yup. (WEB SCRAPIIING LETS GO!! üò±)

The `context` object is useful when the page is dynamic. The context will contain the value of the params. This function is not run at runtime in the browser, so where do the params come in?

That's where `getStaticPaths` come in.

### Static Path (getStaticPath)

getStaticPath, basically if you want to put params, and it's path, so you show next.js here's the path that you can't see because its not on pages folder. maybe its MDX file, generate those, etc.

```jsx
// /pages/blog/:slug.js

const IndexPage = () => {// jsx }
export default IndexPage

export async function getStaticPaths() {
  // get all the paths for your posts from an API
  // or file system
  const results = await fetch('/api/posts')
  const posts = await results.json()
  const paths = posts.map(post => ({params: {slug:
  post.slug}}))
  /* hey generate this two pages please :)
  [
    {params: {slug: 'get-started-with-node'}},
    {params: {slug: 'top-frameworks'}}
  ]
  */
  return {paths}
}

export async function getStaticProps({ params }) {
  const res = await fetch(`/api/post/${params.slug}`)
  const post = await res.json()
  return {
    props: {post}
  }
}
```

You can render static pages ahead of time like blog post etc, but if you have /user/id you dont want to render millions of user page ahead of time lol.

If a page has a dynamic path `[id].jsx` and uses `getStaticProps`, it must also use `getStaticPaths` to prerender all the pages at build time into HTML.

> üëçüèæ¬†¬†**tip**: use `fallback: true` on your return object for `getStaticPaths` if you have a big site and don't want to statically prerender all items at once, and instead opt in to render some later at runtime via SSR.

#### fallback:true

If you have like 20.000 blog post and build time takes long, you can only render 100 most recent ones, and you can SAVE RENDER **when people navigate** there, SO MORE EFFICIENT üò≤

### Server Data

> API handler, but inside component, happens every request.
> Where getStaticProps only happens once at build time.
> This is where you put userID in previous example lol

Lastly we have `getServerSideProps`. This will be called at runtime during every request. So unlike `getStaticProps`, you will have the runtime data like query params, HTTP headers, and the req and res objects from API handlers.

```jsx
const IndexPage = () => {// jsx }
export default IndexPage

export async function getServerSideProps() {
  const response = await fetch(`https://somedata.com`)
  const data = await response.json()

  return { props: { data } }
}
```

## When to use what

**Do you need data at runtime but don't need SSR?** Use client-side data fetching.

**Do you need data at runtime but do need SSR?** Use `getServerSideProps`

> (Most of the time you dont need `getServerSideProps`, so basically if a data is always changing _so you cant render in build time_ but you also have to index it, like /id.. )
> If you have really dynamic pages, just do client side and _hopes the crawler catches it_(?) I heard that during my Internship, he said Tokopedia crawl it's own website.

**Do you have pages that rely on data that is cachable and accessible at build time? Like from a CMS?** Use `getStaticProps`

**Do you have the same as above but the pages have dynamic URL params?** Use `getStaticProps` and `getStaticPaths`

## API Routes Authentication(?)

You can put middleware, just like in [[API Design in Node.js with Express#Custom Middleware]]

```js
const checkAuth = (req, res, next) => {
	if(req.headers.auth)
}
const handler = nc()
  .get((req, res) => {

    const note = getNote(req.query.id)

    if (!note) {
      res.status(404)
      res.end()
      return
    }
		...
```

## getServerSideProps Exampleü§Ø

### Get all notes

In the notes/index.jsx page.

```jsx
/** @jsx jsx */
import { jsx } from 'theme-ui'
import Link from 'next/link'

export default ({ notes }) => {
  return (
    <div sx={{ variant: 'containers.page' }}>
      <h1>My Notes</h1>

      <div
        sx={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          flexWrap: 'wrap',
        }}
      >
        {notes.map((note) => (
          <div sx={{ width: '33%', p: 2 }} key={note.id}>
            <Link href="/notes/[id]" as={`/notes/${note.id}`}>
              <a sx={{ textDecoration: 'none', cursor: 'pointer' }}>
                <div sx={{ variant: 'containers.card' }}>
                  <strong>{note.title}</strong>
                </div>
              </a>
            </Link>
          </div>
        ))}
      </div>
    </div>
  )
}

export async function getServerSideProps() {
  const res = await fetch(`http://localhost:3000/api/note`)
  const { data } = await res.json()
  console.log(data) // this console log to server not client browser

  return {
    props: { notes: data },
  }
}
```

So you declare the code on the bottom there, and can pass it on top WTF
And keep in mind **EVERY CODE IN THERE IS SERVER-SIDE NOT ON CLIENT**

### Get one note

in notes/[id].jsx

```jsx
/** @jsx jsx */
import { jsx } from 'theme-ui'
import { useRouter } from 'next/router'
import Link from 'next/link'

export default ({ data }) => {
  const router = useRouter()

  return (
    <div sx={{ variant: 'containers.page' }}>
      <h1>Note: {note.title} </h1>
    </div>
  )
}

export async function getServerSideProps({ params, req, res }) {
  const response = await fetch(`http://localhost:3000/api/note/${params.id}`)

  // so much power! (can redirect if no exist)
  if (!response.ok) {
    res.writeHead(302, { Location: '/notes' })
    res.end()
    return { props: {} }
  }

  const { data } = await response.json()

  if (data) {
    return {
      props: { note: data },
    }
  }
}
```

## GetStaticProps

### homepage, simulate CMS

```jsx
/** @jsx jsx */
import { jsx } from 'theme-ui'
import Link from 'next/link'

export default ({ content }) => (
  <div sx={{ height: `calc(100vh - 60px)` }}>
    <div
      sx={{
        variant: 'containers.page',
        display: 'flex',
        alignItems: 'center',
        height: '100%',
      }}
    >
      <h1 sx={{ fontSize: 8, my: 0 }}>{content.title}</h1>
    </div>
  </div>
)

export async function getStaticProps() {
  return {
    props: {
      // simulate a CMS
      content: {
        title: 'Look at my note app tho',
      },
    },
  }
}
```

## Can you data fetch inside component?

No, if you do it in the component you have to do it **client-side** just like react, if you want to do server side, then you have to **pass it down as props** or use some ** state management library**

## Rendering Modes

> What is pre-rendering?
> Return html string before goes to the browser, you can put it on the CDN and cache and page will load immediately.

Next.js looks at the data fetching in your page components to determine how and when to prerender your page. Here are the different modes:

`Static Generation` Pages built at build time into HTML. CDN cacheable.

`Server-side Rendering` Pages built at run time into HTML. Cached after the initial hit.

`Client-side Rendering` Single-page app

By default, all pages are prerendered, even if they don't export a data fetching method. You choose the prerendering method (static or SSR) by what data function you export in your page component.

For client-side rendering, fetch your data **inside** your components. You can mix and match these rendering modes to have a genuinely hybrid app ‚ú®.

> Anything that not user change, static generation.
> if you do database thing or map reduce in serversideprops its gonna be crazy, keep in mind

## Working with SSR

Sometimes you just need to skip rendering some component on the server because:

- it depends on the DOM API
- it depends on client-side data
- something else

Next.js supports dynamic imports that, when used with components, will opt out of SSR.

```jsx
import dynamic from 'next/dynamic'

const SponsoredAd = dynamic(() => import('../components/sponsoredAd'), {
  ssr: false,
})

const Page = () => (
  <div>
    <h1>This will be prerendered</h1>

    {/* this won't*/}
    <SponsoredAd />
  </div>
)

export default Page
```

## Deployment

Depending on how you build your app will determine where you can deploy to.

By default, a Next.js app has to be deployed to an environment that supports Node.js. So that's pretty much everywhere expect static hosting services like netlify (not easily anyway).

> üëçüèæ ¬†¬†**tip**: You should deploy to vercel. Vercel literally made Next.js.

If you export your app to be pure static (no need for Node), you can deploy to static hosting services. You can use: `next export`

To do that. There are some [gotchas](https://nextjs.org/docs/advanced-features/static-html-export), though.

> ‚ö†Ô∏è ¬†¬†**warning**: Besure to change the hardcoded API URLS in the fetch calls to use and ENV var for the live URLS.

We're going to deploy to Vercel. It's actually pretty easy. Install the CLI **npm** `npm i -g vercel`

**yarn** `yarn global add vercel`

In your project, run:

```shell
vercel
```

That's it! If your project is already on Github, you can deploy that way from vercel as well. Create an account and connect your Github account.

> If you pushed the code on github, just connect to vercel it's just work.

> YOU GET SCREENSHOT BRANCHES ON EVERY PR, VISUAL DIFF! üò≤

## After Introduction.

There's something called _incremental static generation_ static generation can run at run time aswell?? it's in beta, 500M pages a day!! ü§Øüí•

Gatsby.js can update site on realtime based on your CMS, it will guarantee changes, as in next.js you can't do that, but you can look up _next.js preview mode_.

But gatsby.js has a lot of overhead, because you need to learn graphQL aswell, the whole team had to know graphQL.

There's a open source CMS for javascript Here's a link to [sourcebit](https://github.com/stackbithq/sourcebit)

Also look up [Contentful](https://www.contentful.com/) _free tier!_ for 5 user
And checkout [Stackbit](https://www.stackbit.com/) (it's also contentful but i's like the UI maybe?) Stackbit can visually edit your website (what?)
Stackbit also has **free tier!** for 1 user

> The team of next.js is working with google chrome to make it better??!!!

https://nextjs.org/docs
